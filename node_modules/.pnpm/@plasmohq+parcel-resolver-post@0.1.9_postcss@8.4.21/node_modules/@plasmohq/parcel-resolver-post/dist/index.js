var c=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var O=Object.prototype.hasOwnProperty;var j=(t,e)=>{for(var r in e)c(t,r,{get:e[r],enumerable:!0})},b=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of w(e))!O.call(t,s)&&s!==r&&c(t,s,{get:()=>e[s],enumerable:!(n=T(e,s))||n.enumerable});return t};var F=t=>b(c({},"__esModule",{value:!0}),t);var B={};j(B,{default:()=>U});module.exports=F(B);var M=require("@parcel/plugin");var y=require("@parcel/utils"),o=require("path");var h=require("fs"),m=require("path");var u=[".ts",".tsx",".svelte",".vue",".json",".js",".jsx"],G=new Set(u);var C=/\S+-loader\S*!\S+/g;function R(t=""){if(C.test(t))throw new Error(`The import path: ${t} is using webpack specific loader import syntax, which isn't supported by Parcel.`)}function f(t){return $(t,"*")}function $(t,e){return t.endsWith(e)&&(t=t.substring(0,t.length-e.length)),t}var k=t=>{try{return(0,h.statSync)(t).isFile()}catch{return!1}};function g(t,e=u){return e.flatMap(r=>[(0,m.resolve)(`${t}${r}`),(0,m.resolve)(t,`index${r}`)]).find(k)}var I=/\.(tsx?)|vue|svelte$/,P=[".ts",".tsx",".svelte",".vue",".json",".css",".scss",".sass",".less",".svg",".js",".jsx"],A=new Set(P),p={pathsMap:null,pathsMapRegex:null};async function d(t){try{let{dependency:e}=t;if(R(e.specifier),!I.test(e.resolveFrom))return null;let{compilerOptions:n}=await _(t);if(!n)return null;L(n);let s=W(t);return s?{filePath:s}:null}catch{return null}}function L(t){if(p.pathsMap)return;let e=t.baseUrl||".",r=t.paths||{},n=Object.entries(r).reduce((s,[l,i])=>(s.set(l,i.map(a=>(0,o.join)(e,a))),s),new Map);p.pathsMap=n,p.pathsMapRegex=Array.from(n.entries()).map(s=>[...s,new RegExp(`^${s[0].replace("*",".*")}$`)])}function W({specifier:t,dependency:e}){let{pathsMap:r,pathsMapRegex:n}=p;if(r.has(t))return x(t,t,r.get(t),e.resolveFrom);let s=n.find(([,,l])=>l.test(t));return s?x(t,s[0],s[1],e.resolveFrom):null}function x(t,e,r,n){for(let s of r){let l=(0,o.resolve)(t.replace(f(e),f(s))),i=(0,o.extname)(l);if(i.length>0&&A.has(i))return l;let a=(0,o.extname)(n),S=[a,...P.filter(E=>E!==a)],v=g(l,S);if(v!==null)return v}return null}async function _({options:t,dependency:e}){let r=await(0,y.loadConfig)(t.inputFS,e.resolveFrom,["tsconfig.json","tsconfig.js"],(0,o.join)(process.env.PLASMO_PROJECT_DIR,"lab"));if(!r?.config?.compilerOptions)return null;let n=r.files[0].filePath;return{compilerOptions:r?.config?.compilerOptions,filePath:n}}var U=new M.Resolver({async resolve(t){return await d(t)||null}});0&&(module.exports={});
