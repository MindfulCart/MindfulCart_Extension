var ne=Object.create;var P=Object.defineProperty;var le=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames;var de=Object.getPrototypeOf,he=Object.prototype.hasOwnProperty;var ce=(e,t)=>{for(var r in t)P(e,r,{get:t[r],enumerable:!0})},N=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ue(t))!he.call(e,i)&&i!==r&&P(e,i,{get:()=>t[i],enumerable:!(s=le(t,i))||s.enumerable});return e};var l=(e,t,r)=>(r=e!=null?ne(de(e)):{},N(t||!e||!e.__esModule?P(r,"default",{value:e,enumerable:!0}):r,e)),pe=e=>N(P({},"__esModule",{value:!0}),e);var be={};ce(be,{INTERNAL_RESOLVE:()=>ye,INTERNAL_TRANSFORM:()=>we,Parcel:()=>D});module.exports=pe(be);var W=require("@parcel/core"),G=l(require("@parcel/core/lib/ParcelConfig")),z=l(require("@parcel/core/lib/ReporterRunner")),g=l(require("@parcel/core/lib/RequestTracker")),H=l(require("@parcel/core/lib/dumpGraphToGraphViz")),V=require("@parcel/core/lib/projectPath"),$=require("@parcel/core/lib/public/Asset"),K=require("@parcel/core/lib/public/Bundle"),Q=l(require("@parcel/core/lib/public/BundleGraph")),U=l(require("@parcel/core/lib/requests/ParcelBuildRequest")),J=require("@parcel/core/lib/requests/ParcelConfigRequest"),X=l(require("@parcel/core/lib/requests/ValidationRequest")),w=require("@parcel/core/lib/utils"),B=l(require("@parcel/diagnostic")),Y=require("@parcel/events"),Z=require("@parcel/events"),O=require("@parcel/hash"),F=l(require("@parcel/logger")),ee=require("@parcel/source-map"),te=require("@parcel/utils"),re=require("abortcontroller-polyfill/dist/cjs-ponyfill"),T=l(require("assert")),C=l(require("nullthrows"));var R=require("@parcel/cache"),v=require("@parcel/core/lib/projectPath"),x=require("@parcel/core/lib/requests/ParcelConfigRequest"),S=require("@parcel/fs"),L=require("@parcel/hash"),M=require("@parcel/package-manager"),c=require("@parcel/utils"),a=l(require("path")),fe=["yarn.lock","package-lock.json","pnpm-lock.yaml"];function me(e){return(0,L.hashString)(`${e.join(",")}-${Date.now()}-${Math.round(Math.random()*100)}`)}async function j(e){let t=e.inputFS||new S.NodeFS,r=e.outputFS||new S.NodeFS,s=t.cwd(),i=r.cwd(),o;e.entries==null||e.entries===""?o=[]:Array.isArray(e.entries)?o=e.entries.map(f=>a.default.resolve(s,f)):o=[a.default.resolve(s,e.entries)];let d=!1;if(o.length===1&&!(0,c.isGlob)(o[0])){let[f]=o;try{d=(await t.stat(f)).isDirectory()}catch{}}let p=(0,c.getRootDir)(d?[a.default.join(o[0],"index")]:o),y=await(0,c.resolveConfig)(t,a.default.join(p,"index"),[...fe,".git",".hg"],a.default.parse(p).root)||a.default.join(s,"index"),n=a.default.dirname(y),h=e.packageManager||new M.NodePackageManager(t,n),u=a.default.resolve(i,e.cacheDir),b=e.cache??(r instanceof S.NodeFS?new R.LMDBCache(u):new R.FSCache(r,u)),m=e.mode??"development",E=e?.defaultTargetOptions?.shouldOptimize??m==="production",ie=e?.defaultTargetOptions?.publicUrl??"/",k=e?.defaultTargetOptions?.distDir!=null?a.default.resolve(s,e?.defaultTargetOptions?.distDir):void 0,I=e.shouldBuildLazily??!1,_=e.shouldContentHash??e.mode==="production";if(I&&_)throw new Error("Lazy bundling does not work with content hashing");let se=e.env,oe=ge(e.serveOptions,process.env.PORT);return{config:q(t,n,e.config),defaultConfig:q(t,n,e.defaultConfig),shouldPatchConsole:e.shouldPatchConsole??!1,env:se,mode:m,shouldAutoInstall:e.shouldAutoInstall??!1,hmrOptions:e.hmrOptions??null,shouldBuildLazily:I,shouldBundleIncrementally:e.shouldBundleIncrementally??!0,shouldContentHash:_,serveOptions:e.serveOptions?{...e.serveOptions,distDir:k??a.default.join(i,"dist"),port:oe}:!1,shouldDisableCache:e.shouldDisableCache??!1,shouldProfile:e.shouldProfile??!1,cacheDir:u,entries:o.map(f=>(0,v.toProjectPath)(n,f)),targets:e.targets,logLevel:e.logLevel??"info",projectRoot:n,inputFS:t,outputFS:r,cache:b,packageManager:h,additionalReporters:e.additionalReporters?.map(({packageName:f,resolveFrom:ae})=>({packageName:f,resolveFrom:(0,v.toProjectPath)(n,ae)}))??[],instanceId:me(o),detailedReport:e.detailedReport,defaultTargetOptions:{shouldOptimize:E,shouldScopeHoist:e?.defaultTargetOptions?.shouldScopeHoist,sourceMaps:e?.defaultTargetOptions?.sourceMaps??!0,publicUrl:ie,...k!=null?{distDir:(0,v.toProjectPath)(n,k)}:{},engines:e?.defaultTargetOptions?.engines,outputFormat:e?.defaultTargetOptions?.outputFormat,isLibrary:e?.defaultTargetOptions?.isLibrary}}}function q(e,t,r){if(r!=null)if(a.default.isAbsolute(r)){let s=(0,x.getResolveFrom)(e,t),i=(0,c.relativePath)(a.default.dirname(s),r);return i.startsWith("..")?r:i}else return r}function ge(e,t,r=1234){function s(i){let o=Number(i);if(Number.isInteger(o))return o}return e&&e.port!==r?e.port:typeof t<"u"?s(t)??r:r}(0,w.registerCoreWithSerializer)();var we=Symbol("internal_transform"),ye=Symbol("internal_resolve"),D=class{#r;#f;#e;#n=!1;#o;#a;#i;#h=null;#c;#s;#t=new te.PromiseQueue({maxConcurrent:1});#l;#u;#d=0;#p=new Set;isProfiling;constructor(t){this.#a=t}async _init(){if(this.#n)return;await ee.init,await O.init;let t=await j(this.#a);this.#h=t;let{config:r}=await(0,J.loadParcelConfig)(t);if(this.#f=new G.default(r,t),this.#a.workerFarm){if(this.#a.workerFarm.ending)throw new Error("Supplied WorkerFarm is ending");this.#e=this.#a.workerFarm}else this.#e=(0,W.createWorkerFarm)({shouldPatchConsole:t.shouldPatchConsole});await t.cache.ensure();let{dispose:s,ref:i}=await this.#e.createSharedReference(t,!1);this.#c=i,this.#o=new Z.Disposable,this.#a.workerFarm?this.#o.add(s):this.#o.add(()=>this.#e.end()),this.#l=new Y.ValueEmitter,this.#o.add(()=>this.#l.dispose()),this.#r=await g.default.init({farm:this.#e,options:t}),this.#i=new z.default({config:this.#f,options:t,workerFarm:this.#e}),this.#o.add(this.#i),this.#n=!0}async run(){let t=Date.now();this.#n||await this._init();let r=await this._build({startTime:t});if(await this._end(),r.type==="buildFailure")throw new A(r.diagnostics);return r}async _end(){this.#n=!1,await Promise.all([this.#o.dispose(),await this.#r.writeToCache()])}async _startNextBuild(){this.#s=new re.AbortController,await this.#e.callAllWorkers("clearConfigCache",[]);try{let t=await this._build({signal:this.#s.signal});return this.#l.emit({buildEvent:t}),t}catch(t){if(!(t instanceof w.BuildAbortError))throw t}}async watch(t){this.#n||await this._init();let r;t&&(r=this.#l.addListener(({error:o,buildEvent:d})=>t(o,d))),this.#d===0&&(this.#u=await this._getWatcherSubscription(),await this.#i.report({type:"watchStart"}),this.#t.add(()=>this._startNextBuild()),this.#t.run()),this.#d++;let s,i=async()=>{r&&r.dispose(),this.#d--,this.#d===0&&(await(0,C.default)(this.#u).unsubscribe(),this.#u=null,await this.#i.report({type:"watchEnd"}),this.#s.abort(),await this.#t.run(),await this._end())};return{unsubscribe(){return s==null&&(s=i()),s}}}async _build({signal:t=null,startTime:r=Date.now()}={}){this.#r.setSignal(t);let s=(0,C.default)(this.#h);try{s.shouldProfile&&await this.startProfiling(),this.#i.report({type:"buildStart"}),this.#r.graph.invalidateOnBuildNodes();let i=(0,U.default)({optionsRef:this.#c,requestedAssetIds:this.#p,signal:t}),{bundleGraph:o,bundleInfo:d,changedAssets:p,assetRequests:y}=await this.#r.runRequest(i,{force:!0});this.#p.clear(),(0,H.default)(this.#r.graph,"RequestGraph",g.requestGraphEdgeTypes);let n={type:"buildSuccess",changedAssets:new Map(Array.from(p).map(([h,u])=>[h,(0,$.assetFromValue)(u,s)])),bundleGraph:new Q.default(o,(h,u,b)=>K.PackagedBundle.getWithInfo(h,u,b,d.get(h.id)),s),buildTime:Date.now()-r,requestBundle:async h=>{let u=o._graph.getNodeByContentKey(h.id);if((0,T.default)(u?.type==="bundle","Bundle does not exist"),!u.value.isPlaceholder)return{type:"buildSuccess",changedAssets:new Map,bundleGraph:n.bundleGraph,buildTime:0,requestBundle:n.requestBundle};for(let E of u.value.entryAssetIds)this.#p.add(E);this.#t.getNumWaiting()===0&&(this.#s&&this.#s.abort(),this.#t.add(()=>this._startNextBuild()));let m=(await this.#t.run()).filter(Boolean).pop();if(m.type==="buildFailure")throw new A(m.diagnostics);return m}};return await this.#i.report(n),await this.#r.runRequest((0,X.default)({optionsRef:this.#c,assetRequests:y}),{force:y.length>0}),n}catch(i){if(i instanceof w.BuildAbortError)throw i;let o=(0,B.anyToDiagnostic)(i),d={type:"buildFailure",diagnostics:Array.isArray(o)?o:[o]};return await this.#i.report(d),d}finally{this.isProfiling&&await this.stopProfiling(),await this.#e.callAllWorkers("clearConfigCache",[])}}async _getWatcherSubscription(){(0,T.default)(this.#u==null);let t=(0,C.default)(this.#h),r=(0,g.getWatcherOptions)(t),s=await t.inputFS.watch(t.projectRoot,(i,o)=>{if(i){this.#l.emit({error:i});return}this.#r.respondToFSEvents(o.map(p=>({type:p.type,path:(0,V.toProjectPath)(t.projectRoot,p.path)})))&&this.#t.getNumWaiting()===0&&(this.#s&&this.#s.abort(),this.#t.add(()=>this._startNextBuild()),this.#t.run())},r);return{unsubscribe:()=>s.unsubscribe()}}async startProfiling(){if(this.isProfiling)throw new Error("Parcel is already profiling");F.default.info({origin:"@parcel/core",message:"Starting profiling..."}),this.isProfiling=!0,await this.#e.startProfile()}stopProfiling(){if(!this.isProfiling)throw new Error("Parcel is not profiling");return F.default.info({origin:"@parcel/core",message:"Stopping profiling..."}),this.isProfiling=!1,this.#e.endProfile()}takeHeapSnapshot(){return F.default.info({origin:"@parcel/core",message:"Taking heap snapshot..."}),this.#e.takeHeapSnapshot()}},A=class extends B.default{constructor(t){super({diagnostic:t}),this.name="BuildError"}};0&&(module.exports={INTERNAL_RESOLVE,INTERNAL_TRANSFORM,Parcel});
